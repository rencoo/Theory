for (var i = 0; i < 10; i++) {
    setTimeout(function(){
        console.log(i);
    }, 1000 * i)
}
// 异步代码；setTimeout 函数执行的时候，外面环境的 i 已经是 10 了
// 输出 10 个 10

// 主要原因，主要是for循环,只声明了一次 i，后面 几次直接覆盖在定义的 i 上，也就是说每次迭代时定义的函数，它们的词法作用域只有一个 i

// 我们对这段代码行为的预期是分别输出数字1~5，每秒一次，每次一个
// 但这段代码在实际运行时会以每秒一次的频率输出五次6

// 延迟函数的回调会在循环结束时才执行。事实上，
// 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循
// 环结束后才会被执行，因此会每次输出一个6 出来。

// 这里引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不一 !!!!!!!!
// 致呢？

/**缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i 的副本。但是 !!!!!!
 *根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，
 *但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。！！！！！！！！！！！
 */


    for (var i=1; i<=5; i++) {
        (function() {
            // 新增的词法作用域
            setTimeout(function timer() {
                console.log( i );
            }, i*1000 );

        })();
    }

// 这样不行,仍旧输出五个 6
/**虽然现在显然拥有更多的词法作用域了。--------------------------------------------
 *的确每个延迟函数都会将IIFE 在每次迭代中创建的作用域封闭起来。 !!!!!!!!!!!!!!!!!!!!
 *如果作用域是空的，那么仅仅将它们进行封闭是不够的。
 *仔细看一下，我们的IIFE 只是一个什么都没有的空作用域。
 */



for (var i=1; i<=5; i++) {
    (function() {
        var j = i; // 创建自己的变量，用来在每个迭代中储存 i；每次都声明
        // for 循环中的 i 值被保存保护起来了
        // console.log('j1 is', j)
        setTimeout(function timer() {
            console.log( j );
        }, j*1000 );
    })();
}

// 正常工作，分别输出数字1~5
// 每次 i 都在内部函数体内重新声明了(最关键的原因)，因此每个迭代创建函数时，它的词法作用域是不同的 i
// 词法作用域 j 和 本身(创建的函数)
// 重新声明很重要！！！！！！！！！！！！！！！！！！！！！ 而 for 只声明一次


// 对这段代码进行一些改进

    for (var i=1; i<=5; i++) {
        (function(j) { // 依赖注入 等同于 var j = i;
            setTimeout( function timer() {
                console.log( j );
            }, j*1000 );
        })(i);
    }


// 正常工作，分别输出数字1~5
//  形参，既然它是一个形参，那么就可以被内部的函数所访问，同时内部的函数就保存了它的外层的做作用域

/**这个函数在定义时的词法作用域以外(全局)的地方被调用。闭包 使得函数可以继续访问 定义时 的！！！！！！
 *词法作用域。---------------------------------------------------------访问状态
 */
 // 这里的 j 就是我们函数在定义时的 新的 词法作用域；就算之后访问，也能访问到定义时的词法作用域；

/**在迭代内使用IIFE 会为每个迭代都生成一个 新的作用域 ，使得延迟函数的回调可以将 新的
 *作用域 封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。
 */



for (var i = 0; i < 10; i++){
    (function(j){
        setTimeout(function(){
            console.log(j);
        }, 1000 * j)
    })(i)
}
// 成功输出 0 1 2 3 4 5 6  7 8 9
// 通过IIFE，创造了一层作用域，这样setTimeout找j的时候，根据作用域链，就先查找到了这里注入的i。！！！！
// setTimeout 函数执行的时候，能访问到每次迭代时被新作用域 保护起来的i (保护起来的！！！)
// 在迭代内使用IIFE 会为每个迭代都生成一个 新的作用域 ，使得延迟函数的回调可以将新的
// 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。

ES6
for(var i = 0; i < 10; i++){
    let j = i; // 是的，块作用域！没有函数级作用域(闭包)，直接是块作用域；
    setTimeout(function(){
        console.log(j)
    }, 1000 * j)
}
// 正常输出 0 - 9

for(var i = 0; i < 10; i++){
    {
        let j = i; 
        setTimeout(function(){
            console.log(j)
        }, 1000 * j)
    }
}


/**
 *但是，这还不是全部！for 循环头部的 let 声明还会有一个特殊的行为。-----------------
 *这个行为指出变量在循环过程中 不止被声明一次 ，每次迭代都会声明。-------------------(关键，只要每次迭代都声明了就有效！！！！)
 *随后的每个迭代都会使用上一个迭代结束时的值来 初始化 这个变量。-----------------------
 */
for(let i = 0; i < 10; i++){
    setTimeout(function(){
        console.log(i)
    }, 1000 * i)
}
// 正常输出 0 - 9
/**
 *块作用域和闭包联手便可天下无敌。不知道你是什么情况，
 *反正这个功能让我成为了一名快乐的JavaScript 程序员。
 */


// ES5 bind !!!!----------------------------------------------------------------
for(var i = 0; i < 10; i++) {
    setTimeout((function(j){
        console.log(j);
    }).bind(null, i), 1000 * i);
}
// 正常输出 0 - 9
// bind 作用之一就是 传递参数
// bind 可以传一部分参数进去；叫做部分调用函数；函数并未真正执行，但已经把i bind 进去了，
// 等function真正执行的时候，i 就是我们之前 bind 的 i (先传参，不立即执行)

// 网易
// -----------------------------------------------------------------------
// 这段代码是做一个 事件注册，在 addHandlers 里面会为 一组元素注册 onclick 事件，
// 当这个 onclick 触发的时候，可以把元素的索引打出来，因为是一组元素，所以索引是 0 1 2 ...
// 不能符合预期
var addHandlers = function(nodes) {
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].onclick = function() {
            alert(i);
        }
    }
}

// 修改
var addHandlers = function(node) {
    var helper = function(i) {
        return function() {
            alert(i);
        }
    }
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].onclick = helper(i);
    }
}

// 我们把 nodes[i].onclick 赋成了 helper 函数，
// helper 函数里面去 返回了一个 函数
// 用返回的函数去 alert(i)
// 实际上这里面的 helper 就是一个闭包的作用
// 当 helper 函数接受了 i 这个值之后， 这个 i 在helper 函数里面就是一个 形参，
// 既然它是一个形参，那么就可以被内部的函数所访问，
// 同时内部的函数就保存了它的外层的做作用域(return 的函数 保存了 helper的作用域)，
// 那么这个时候就把传入的 i 的值给保存下来，也就是 helper 这个闭包的作用；当循环每一次调用 onclick 的时候， 
// helper 都会产生一个闭包，都会把当前你传入的值给保存下来，
// 将来当我去点这个元素的时候，去执行这个函数的时候，它就会弹出 你当时传进去的那个值 就是这个 i，
// 这样就达到了 保存变量现场 的目的